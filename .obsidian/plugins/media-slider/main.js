/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MediaSliderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/compression.ts
async function compressImage(imageUrl, maxWidth = 800, maxHeight = 600, quality = 0.7) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "Anonymous";
    img.onload = () => {
      let { width, height } = img;
      let newWidth = width;
      let newHeight = height;
      if (width > maxWidth || height > maxHeight) {
        const widthRatio = maxWidth / width;
        const heightRatio = maxHeight / height;
        const ratio = Math.min(widthRatio, heightRatio);
        newWidth = width * ratio;
        newHeight = height * ratio;
      }
      const canvas = document.createElement("canvas");
      canvas.width = newWidth;
      canvas.height = newHeight;
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        reject("Canvas context not available");
        return;
      }
      ctx.drawImage(img, 0, 0, newWidth, newHeight);
      const dataUrl = canvas.toDataURL("image/jpeg", quality);
      resolve(dataUrl);
    };
    img.onerror = (err) => reject(err);
    img.src = imageUrl;
  });
}

// src/notes.ts
var NotesManager = class {
  constructor(plugin) {
    this.data = {};
    this.plugin = plugin;
  }
  async load() {
    const loaded = await this.plugin.loadData();
    this.data = loaded || {};
  }
  async save() {
    await this.plugin.saveData(this.data);
  }
  getNote(key) {
    return this.data[key] || "";
  }
  async setNote(key, note) {
    this.data[key] = note;
    await this.save();
  }
  // Removes notes for the specified slider that are not in the validFiles list.
  async cleanupNotesForSlider(sliderId, validFiles) {
    for (const key of Object.keys(this.data)) {
      if (key.startsWith(`${sliderId}-`)) {
        const mediaFile = key.substring(sliderId.length + 1);
        if (!validFiles.includes(mediaFile)) {
          delete this.data[key];
        }
      }
    }
    await this.save();
  }
};

// src/drawing.ts
var DrawingAnnotation = class {
  constructor(container) {
    this.drawing = false;
    this.startX = 0;
    this.startY = 0;
    // The current tool (for freehand, eraser, laser) and for geometric tools.
    this.currentTool = "freehand";
    this.currentGeometricTool = "line";
    // Public drawing settings.
    this.color = "#FF0000";
    // default red
    this.lineWidth = 2;
    this.resizeCanvasBound = () => {
      this.resizeCanvas();
    };
    this.handlePointerDown = (e) => {
      this.drawing = true;
      this.startX = e.offsetX;
      this.startY = e.offsetY;
      if (this.currentTool === "freehand" || this.currentTool === "eraser" || this.currentTool === "laser") {
        this.ctx.beginPath();
        this.ctx.moveTo(this.startX, this.startY);
      }
    };
    this.handlePointerMove = (e) => {
      if (!this.drawing)
        return;
      const currentX = e.offsetX;
      const currentY = e.offsetY;
      if (this.currentTool === "freehand") {
        this.ctx.strokeStyle = this.color;
        this.ctx.lineWidth = this.lineWidth;
        this.ctx.lineCap = "round";
        this.ctx.lineTo(currentX, currentY);
        this.ctx.stroke();
      } else if (this.currentTool === "laser") {
        this.ctx.strokeStyle = this.color;
        this.ctx.lineWidth = 1;
        this.ctx.lineCap = "round";
        this.ctx.shadowColor = this.color;
        this.ctx.shadowBlur = 10;
        this.ctx.lineTo(currentX, currentY);
        this.ctx.stroke();
        this.ctx.shadowBlur = 0;
      } else if (this.currentTool === "eraser") {
        this.ctx.globalCompositeOperation = "destination-out";
        this.ctx.lineWidth = this.lineWidth * 5;
        this.ctx.lineTo(currentX, currentY);
        this.ctx.stroke();
        this.ctx.globalCompositeOperation = "source-over";
      }
    };
    this.handlePointerUp = (e) => {
      if (!this.drawing)
        return;
      this.drawing = false;
      const endX = e.offsetX;
      const endY = e.offsetY;
      this.ctx.strokeStyle = this.currentTool === "eraser" ? "rgba(0,0,0,1)" : this.color;
      this.ctx.lineWidth = this.lineWidth;
      this.ctx.lineCap = "round";
      if (this.currentTool === "line") {
        this.ctx.beginPath();
        this.ctx.moveTo(this.startX, this.startY);
        this.ctx.lineTo(endX, endY);
        this.ctx.stroke();
      } else if (this.currentTool === "rectangle") {
        const rectWidth = endX - this.startX;
        const rectHeight = endY - this.startY;
        this.ctx.strokeRect(this.startX, this.startY, rectWidth, rectHeight);
      } else if (this.currentTool === "circle") {
        const radius = Math.sqrt(Math.pow(endX - this.startX, 2) + Math.pow(endY - this.startY, 2));
        this.ctx.beginPath();
        this.ctx.arc(this.startX, this.startY, radius, 0, Math.PI * 2);
        this.ctx.stroke();
      } else if (this.currentTool === "laser") {
        setTimeout(() => {
          this.clear();
        }, 200);
      }
    };
    this.container = container;
    this.canvas = document.createElement("canvas");
    this.canvas.classList.add("drawing-canvas");
    this.container.appendChild(this.canvas);
    this.resizeCanvas();
    const ctx = this.canvas.getContext("2d");
    if (!ctx)
      throw new Error("Cannot get 2D context");
    this.ctx = ctx;
    this.toolbar = document.createElement("div");
    this.toolbar.classList.add("drawing-toolbar");
    this.container.appendChild(this.toolbar);
    this.createToolbar();
    this.enableDrawing();
    window.addEventListener("resize", this.resizeCanvasBound);
  }
  resizeCanvas() {
    this.canvas.width = this.container.clientWidth;
    this.canvas.height = this.container.clientHeight;
  }
  resetToolbarHighlights() {
    Array.from(this.toolbar.children).forEach((child) => {
      child.classList.remove("active-tool");
    });
  }
  createToolbar() {
    const freehandBtn = document.createElement("button");
    freehandBtn.textContent = "\u270F\uFE0F";
    freehandBtn.title = "Freehand";
    freehandBtn.classList.add("drawing-btn", "freehand-btn");
    freehandBtn.onclick = () => {
      this.currentTool = "freehand";
      this.resetToolbarHighlights();
      freehandBtn.classList.add("active-tool");
    };
    this.toolbar.appendChild(freehandBtn);
    const geomDropdown = document.createElement("details");
    geomDropdown.classList.add("drawing-dropdown");
    const geomSummary = document.createElement("summary");
    geomSummary.textContent = "\u2796";
    geomSummary.title = "Geometric tools (line, rect, circle)";
    geomSummary.classList.add("drawing-dropdown-summary");
    geomDropdown.appendChild(geomSummary);
    const geomOptions = document.createElement("div");
    geomOptions.classList.add("drawing-dropdown-options");
    const geomTools = [
      { tool: "line", icon: "\u2796", label: "Line" },
      { tool: "rectangle", icon: "\u25AD", label: "Rectangle" },
      { tool: "circle", icon: "\u25EF", label: "Circle" }
    ];
    geomTools.forEach((opt) => {
      const btn = document.createElement("button");
      btn.textContent = opt.icon;
      btn.title = opt.label;
      btn.classList.add("drawing-btn", "geom-tool-btn");
      btn.onclick = (e) => {
        e.stopPropagation();
        this.currentTool = opt.tool;
        this.currentGeometricTool = opt.tool;
        geomSummary.textContent = opt.icon;
        geomDropdown.removeAttribute("open");
      };
      geomOptions.appendChild(btn);
    });
    geomDropdown.appendChild(geomOptions);
    this.toolbar.appendChild(geomDropdown);
    const eraserBtn = document.createElement("button");
    eraserBtn.textContent = "\u{1F9FD}";
    eraserBtn.title = "Eraser";
    eraserBtn.classList.add("drawing-btn", "eraser-btn");
    eraserBtn.onclick = () => {
      this.currentTool = "eraser";
      this.resetToolbarHighlights();
      eraserBtn.classList.add("active-tool");
    };
    this.toolbar.appendChild(eraserBtn);
    const laserBtn = document.createElement("button");
    laserBtn.textContent = "\u{1F526}";
    laserBtn.title = "Laser (temporary)";
    laserBtn.classList.add("drawing-btn", "laser-btn");
    laserBtn.onclick = () => {
      this.currentTool = "laser";
      this.resetToolbarHighlights();
      laserBtn.classList.add("active-tool");
    };
    this.toolbar.appendChild(laserBtn);
    const colorInput = document.createElement("input");
    colorInput.type = "color";
    colorInput.value = this.color;
    colorInput.classList.add("drawing-color-input");
    colorInput.onchange = () => {
      this.color = colorInput.value;
    };
    this.toolbar.appendChild(colorInput);
    const widthInput = document.createElement("input");
    widthInput.type = "number";
    widthInput.min = "1";
    widthInput.max = "10";
    widthInput.value = this.lineWidth.toString();
    widthInput.classList.add("drawing-linewidth-input");
    widthInput.onchange = () => {
      this.lineWidth = Number(widthInput.value);
    };
    this.toolbar.appendChild(widthInput);
  }
  enableDrawing() {
    this.canvas.addEventListener("pointerdown", this.handlePointerDown);
    this.canvas.addEventListener("pointermove", this.handlePointerMove);
    this.canvas.addEventListener("pointerup", this.handlePointerUp);
    this.canvas.addEventListener("pointerout", this.handlePointerUp);
  }
  disableDrawing() {
    this.canvas.removeEventListener("pointerdown", this.handlePointerDown);
    this.canvas.removeEventListener("pointermove", this.handlePointerMove);
    this.canvas.removeEventListener("pointerup", this.handlePointerUp);
    this.canvas.removeEventListener("pointerout", this.handlePointerUp);
  }
  clear() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  getAnnotation() {
    return this.canvas.toDataURL("image/png");
  }
  destroy() {
    window.removeEventListener("resize", this.resizeCanvasBound);
    this.disableDrawing();
    if (this.toolbar.parentNode)
      this.toolbar.parentNode.removeChild(this.toolbar);
    if (this.canvas.parentNode)
      this.canvas.parentNode.removeChild(this.canvas);
  }
};

// src/visualizer.ts
var Visualizer = class {
  constructor(mediaElement, container, options = {}) {
    var _a, _b, _c;
    this.mediaElement = mediaElement;
    this.container = container;
    this.options = {
      height: (_a = options.height) != null ? _a : "100px",
      gradientType: (_b = options.gradientType) != null ? _b : "blue-red",
      customColors: options.customColors
    };
    const resolvedHeight = (_c = this.options.height) != null ? _c : "100px";
    this.canvas = document.createElement("canvas");
    this.canvas.classList.add("visualizer-canvas");
    const heightValue = resolvedHeight.replace("px", "");
    this.canvas.classList.add(`visualizer-height-${heightValue}`);
    this.canvas.width = container.clientWidth;
    this.canvas.height = parseInt(resolvedHeight, 10);
    this.canvasCtx = this.canvas.getContext("2d");
    container.appendChild(this.canvas);
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    this.source = this.audioContext.createMediaElementSource(this.mediaElement);
    this.analyser = this.audioContext.createAnalyser();
    this.analyser.fftSize = 512;
    this.analyser.smoothingTimeConstant = 0.05;
    this.analyser.minDecibels = -100;
    this.analyser.maxDecibels = -30;
    this.source.connect(this.analyser);
    this.analyser.connect(this.audioContext.destination);
    this.animationFrameId = 0;
    this.draw();
  }
  draw() {
    const bufferLength = this.analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    const halfBins = Math.floor(bufferLength / 2);
    const gap = 2;
    const canvasWidth = this.canvas.width;
    const canvasHeight = this.canvas.height;
    const midX = canvasWidth / 2;
    const baseline = canvasHeight / 2;
    const slotWidth = midX / halfBins;
    const barWidth = slotWidth * 0.6;
    const drawBars = () => {
      this.analyser.getByteFrequencyData(dataArray);
      this.canvasCtx.clearRect(0, 0, canvasWidth, canvasHeight);
      for (let i = 0; i < halfBins; i++) {
        const rawIntensity = dataArray[i] / 255;
        const intensity = Math.pow(rawIntensity, 2);
        const barHeight = intensity * baseline;
        let gradient;
        if (this.options.gradientType === "blue-red") {
          gradient = this.canvasCtx.createLinearGradient(0, baseline, 0, baseline - barHeight);
          gradient.addColorStop(0, "hsl(240,80%,40%)");
          gradient.addColorStop(1, "hsl(0,90%,50%)");
        } else if (this.options.gradientType === "rainbow") {
          gradient = this.canvasCtx.createLinearGradient(0, baseline, 0, baseline - barHeight);
          gradient.addColorStop(0, "hsl(240,100%,50%)");
          gradient.addColorStop(0.25, "hsl(180,100%,50%)");
          gradient.addColorStop(0.5, "hsl(120,100%,50%)");
          gradient.addColorStop(0.75, "hsl(60,100%,50%)");
          gradient.addColorStop(1, "hsl(0,100%,50%)");
        } else if (this.options.gradientType === "custom" && this.options.customColors && this.options.customColors.length > 0) {
          gradient = this.canvasCtx.createLinearGradient(0, baseline, 0, baseline - barHeight);
          const n = this.options.customColors.length;
          for (let j = 0; j < n; j++) {
            gradient.addColorStop(j / (n - 1), this.options.customColors[j]);
          }
        } else {
          gradient = this.canvasCtx.createLinearGradient(0, baseline, 0, baseline - barHeight);
          gradient.addColorStop(0, "hsl(240,100%,50%)");
          gradient.addColorStop(0.25, "hsl(180,100%,50%)");
          gradient.addColorStop(0.5, "hsl(120,100%,50%)");
          gradient.addColorStop(0.75, "hsl(60,100%,50%)");
          gradient.addColorStop(1, "hsl(0,100%,50%)");
        }
        const xRight = midX + i * (barWidth + gap);
        const xLeft = midX - (i + 1) * (barWidth + gap);
        this.canvasCtx.fillStyle = gradient;
        this.canvasCtx.fillRect(xRight, baseline - barHeight, barWidth, barHeight);
        this.canvasCtx.fillRect(xLeft, baseline - barHeight, barWidth, barHeight);
      }
      this.animationFrameId = requestAnimationFrame(drawBars);
    };
    drawBars();
  }
  destroy() {
    cancelAnimationFrame(this.animationFrameId);
    this.canvas.remove();
    this.source.disconnect();
    this.analyser.disconnect();
    if (this.audioContext.state !== "closed") {
      this.audioContext.close();
    }
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  enableDrawingAnnotation: false,
  enableVisualizer: false,
  visualizerColor: "#00ff00",
  visualizerHeight: "50px"
};
var _MediaSliderPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.filePathCache = /* @__PURE__ */ new Map();
    this.markdownCache = /* @__PURE__ */ new Map();
    this.drawingData = {};
  }
  async onload() {
    console.log("Loading Media Slider Plugin...");
    await this.loadSettings();
    this.addSettingTab(new MediaSliderSettingTab(this.app, this));
    this.notesManager = new NotesManager(this);
    await this.notesManager.load();
    await this.loadDrawingData();
    this.registerMarkdownCodeBlockProcessor("media-slider", (source, el, ctx) => {
      this.createMediaSlider(source, el, ctx);
    });
  }
  // --- Settings Persistence ---
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // --- Force Refresh for Immediate Settings Effect ---
  refreshSliders() {
    this.app.workspace.getLeavesOfType("markdown").forEach((leaf) => {
      if (leaf.view instanceof import_obsidian.MarkdownView && typeof leaf.view.load === "function") {
        leaf.view.load();
      }
    });
  }
  // --- Persistent Drawing Data Management ---
  async loadDrawingData() {
    const data = await this.loadData();
    this.drawingData = (data == null ? void 0 : data.drawings) || {};
  }
  async saveDrawingData() {
    const data = await this.loadData() || {};
    data.drawings = this.drawingData;
    await this.saveData(data);
  }
  async cleanupDrawingData(sliderId, validFiles) {
    for (const key of Object.keys(this.drawingData)) {
      if (key.startsWith(`${sliderId}-`)) {
        const mediaFile = key.substring(sliderId.length + 1);
        if (!validFiles.includes(mediaFile)) {
          delete this.drawingData[key];
        }
      }
    }
    await this.saveDrawingData();
  }
  // --- Resource Helpers ---
  getCachedResourcePath(fileName) {
    if (this.filePathCache.has(fileName)) {
      return this.filePathCache.get(fileName);
    }
    const path = this.app.vault.adapter.getResourcePath(fileName);
    this.filePathCache.set(fileName, path);
    return path;
  }
  getMediaSource(fileName) {
    if (fileName.startsWith("http://") || fileName.startsWith("https://")) {
      return fileName;
    }
    let file = this.app.vault.getAbstractFileByPath(fileName);
    if (!file) {
      const matchingFiles = this.app.vault.getFiles().filter(
        (f) => f.name.toLowerCase() === fileName.toLowerCase()
      );
      if (matchingFiles.length > 0) {
        fileName = matchingFiles[0].path;
      } else {
        console.error("File not found in vault:", fileName);
      }
    }
    return this.getCachedResourcePath(fileName);
  }
  // --- Revised getMarkdownContent without unsafe casting ---
  async getMarkdownContent(fileName) {
    if (this.markdownCache.has(fileName)) {
      return this.markdownCache.get(fileName);
    }
    const abstractFile = this.app.vault.getAbstractFileByPath(fileName);
    if (abstractFile && "extension" in abstractFile) {
      const content = await this.app.vault.read(abstractFile);
      this.markdownCache.set(fileName, content);
      return content;
    }
    return "";
  }
  throttle(fn, delay) {
    let lastCall = 0;
    return (...args) => {
      const now = Date.now();
      if (now - lastCall < delay)
        return;
      lastCall = now;
      return fn(...args);
    };
  }
  // --- Slider Creation ---
  createMediaSlider(source, el, ctx) {
    const metadataMatch = source.match(/---\n([\s\S]+?)\n---/);
    const mediaContent = source.replace(/---\n[\s\S]+?\n---/, "").trim();
    const mediaFiles = mediaContent.split("\n").map((line) => line.trim()).filter(Boolean);
    let settings = {
      sliderId: "",
      carouselShowThumbnails: true,
      thumbnailPosition: "bottom",
      captionMode: "overlay",
      autoplay: false,
      slideshowSpeed: 0,
      width: "100%",
      height: "350px",
      transitionEffect: "fade",
      transitionDuration: 500,
      enhancedView: true,
      interactiveNotes: false
    };
    if (metadataMatch) {
      try {
        const parsedSettings = (0, import_obsidian.parseYaml)(metadataMatch[1]);
        settings = Object.assign(settings, parsedSettings);
      } catch (error) {
        console.error("Failed to parse media-slider metadata:", error);
      }
    }
    let sliderId = settings.sliderId;
    if (!sliderId) {
      sliderId = `slider-${_MediaSliderPlugin.sliderCounter++}`;
    }
    const validFiles = mediaFiles.map((file) => {
      let match = file.match(/!?\[\[(.*?)\]\]/);
      if (!match) {
        match = file.match(/!\[\]\((.*?)\)/);
      }
      return match ? match[1] : "";
    }).filter(Boolean);
    if (validFiles.length === 0) {
      el.createEl("p", { text: "No valid media files found." });
      return;
    }
    this.notesManager.cleanupNotesForSlider(sliderId, validFiles).catch(console.error);
    this.cleanupDrawingData(sliderId, validFiles).catch(console.error);
    this.renderSlider(el, validFiles, settings, sliderId);
  }
  // --- Render Slider UI ---
  renderSlider(container, files, settings, sliderId) {
    container.empty();
    let updateDrawingOverlay;
    const sliderWrapper = container.createDiv("media-slider-wrapper");
    if (settings.carouselShowThumbnails && (settings.thumbnailPosition === "left" || settings.thumbnailPosition === "right")) {
      sliderWrapper.classList.add("flex-row");
    } else {
      sliderWrapper.classList.add("flex-column", "center");
    }
    const sliderContent = sliderWrapper.createDiv("slider-content");
    const sliderContainer = sliderContent.createDiv("slider-container");
    const captionContainer = sliderContent.createDiv("slider-caption-container");
    let thumbnailContainer = null;
    let thumbnailEls = [];
    if (settings.carouselShowThumbnails) {
      thumbnailContainer = document.createElement("div");
      thumbnailContainer.classList.add("thumbnail-container");
      if (settings.thumbnailPosition === "left" || settings.thumbnailPosition === "right") {
        thumbnailContainer.classList.add("vertical");
      } else {
        thumbnailContainer.classList.add("horizontal");
      }
      if (settings.thumbnailPosition === "top" || settings.thumbnailPosition === "left") {
        sliderWrapper.insertBefore(thumbnailContainer, sliderContent);
      } else if (settings.thumbnailPosition === "bottom" || settings.thumbnailPosition === "right") {
        sliderWrapper.appendChild(thumbnailContainer);
      }
    }
    let currentIndex = 0;
    let currentDirection = "next";
    if (settings.enhancedView) {
      const fullScreenBtn = sliderWrapper.createEl("button", { text: "\u26F6", cls: "fullscreen-btn" });
      fullScreenBtn.onclick = () => {
        if (!document.fullscreenElement) {
          sliderWrapper.requestFullscreen().catch((err) => console.error("Error enabling fullscreen:", err));
          sliderContainer.classList.add("fullscreen-slider");
        } else {
          document.exitFullscreen();
          sliderContainer.classList.remove("fullscreen-slider");
        }
      };
      const copyBtn = sliderWrapper.createEl("button", { text: "\u{1F4CB}", cls: "copy-btn" });
      copyBtn.onclick = async () => {
        const currentEntry = files[currentIndex];
        let [fileName] = currentEntry.split("|").map((s) => s.trim());
        const markdownLink = `![[${fileName}]]`;
        try {
          await navigator.clipboard.writeText(markdownLink);
          console.log("Copied markdown link to clipboard:", markdownLink);
        } catch (err) {
          console.error("Failed to copy markdown link:", err);
        }
      };
    }
    let notesContainer = null;
    let notesTextarea = null;
    let notesToggleBtn = null;
    if (settings.interactiveNotes) {
      notesToggleBtn = sliderWrapper.createEl("button", { text: "\u{1F4DD}", cls: "notes-toggle-btn" });
      notesToggleBtn.onclick = () => {
        if (notesContainer) {
          notesContainer.classList.toggle("visible");
          const mediaKey = `${sliderId}-${files[currentIndex]}`;
          if (notesContainer.classList.contains("visible") && notesTextarea) {
            notesTextarea.value = this.notesManager.getNote(mediaKey);
          }
        }
      };
      notesContainer = sliderWrapper.createDiv("notes-container");
      notesTextarea = document.createElement("textarea");
      notesTextarea.classList.add("notes-textarea");
      notesTextarea.placeholder = "Add your notes here...";
      notesContainer.appendChild(notesTextarea);
      const saveNotesBtn = document.createElement("button");
      saveNotesBtn.textContent = "\u{1F4BE}";
      saveNotesBtn.classList.add("notes-save-btn");
      saveNotesBtn.onclick = async () => {
        const mediaKey = `${sliderId}-${files[currentIndex]}`;
        if (notesTextarea) {
          await this.notesManager.setNote(mediaKey, notesTextarea.value);
        }
        if (notesContainer)
          notesContainer.classList.remove("visible");
      };
      notesContainer.appendChild(saveNotesBtn);
    }
    let drawingAnnotation = null;
    let clearDrawingBtn = null;
    if (this.settings.enableDrawingAnnotation) {
      const drawingToggleBtn = sliderWrapper.createEl("button", { text: "\u270F\uFE0F", cls: "drawing-toggle-btn" });
      updateDrawingOverlay = (mediaKey) => {
        const existingOverlay = sliderContainer.querySelector(".drawing-overlay");
        if (existingOverlay) {
          existingOverlay.remove();
        }
        const savedDrawing = this.drawingData[mediaKey];
        if (savedDrawing) {
          const overlay = sliderContainer.createEl("img", { attr: { src: savedDrawing } });
          overlay.classList.add("drawing-overlay");
          if (!clearDrawingBtn) {
            clearDrawingBtn = sliderWrapper.createEl("button", { text: "\u{1F5D1}\uFE0F", cls: "clear-drawing-btn" });
            clearDrawingBtn.onclick = async () => {
              delete this.drawingData[mediaKey];
              await this.saveDrawingData();
              const existingOverlay2 = sliderContainer.querySelector(".drawing-overlay");
              if (existingOverlay2)
                existingOverlay2.remove();
              clearDrawingBtn.remove();
              clearDrawingBtn = null;
            };
          }
        } else {
          if (clearDrawingBtn) {
            clearDrawingBtn.remove();
            clearDrawingBtn = null;
          }
        }
      };
      drawingToggleBtn.onclick = async () => {
        const mediaKey = `${sliderId}-${files[currentIndex]}`;
        if (drawingAnnotation) {
          const drawingDataUrl = drawingAnnotation.getAnnotation();
          this.drawingData[mediaKey] = drawingDataUrl;
          await this.saveDrawingData();
          drawingAnnotation.destroy();
          drawingAnnotation = null;
          drawingToggleBtn.textContent = "\u270F\uFE0F";
          updateDrawingOverlay == null ? void 0 : updateDrawingOverlay(mediaKey);
        } else {
          if (this.drawingData[mediaKey]) {
            delete this.drawingData[mediaKey];
            await this.saveDrawingData();
            const existingOverlay = sliderContainer.querySelector(".drawing-overlay");
            if (existingOverlay)
              existingOverlay.remove();
            if (clearDrawingBtn) {
              clearDrawingBtn.remove();
              clearDrawingBtn = null;
            }
          }
          drawingAnnotation = new DrawingAnnotation(sliderContainer);
          drawingToggleBtn.textContent = "\u{1F4BE}";
        }
      };
    }
    container.appendChild(sliderWrapper);
    const prevBtn = sliderContent.createEl("button", { text: "\u2B9C", cls: "slider-btn prev" });
    const nextBtn = sliderContent.createEl("button", { text: "\u2B9E", cls: "slider-btn next" });
    const updateMediaDisplay = async () => {
      sliderContainer.classList.remove(
        "transition-fade-in",
        "transition-slide-next-in",
        "transition-slide-prev-in",
        "transition-zoom-in",
        "transition-slide-up-in",
        "transition-slide-down-in",
        "transition-flip-in",
        "transition-flip-vertical-in",
        "transition-rotate-in",
        "transition-blur-in",
        "transition-squeeze-in"
      );
      switch (settings.transitionEffect) {
        case "fade":
          sliderContainer.classList.add("transition-fade-out");
          break;
        case "slide":
          sliderContainer.classList.add(currentDirection === "next" ? "transition-slide-next-out" : "transition-slide-prev-out");
          break;
        case "zoom":
          sliderContainer.classList.add("transition-zoom-out");
          break;
        case "slide-up":
          sliderContainer.classList.add("transition-slide-up-out");
          break;
        case "slide-down":
          sliderContainer.classList.add("transition-slide-down-out");
          break;
        case "flip":
          sliderContainer.classList.add("transition-flip-out");
          break;
        case "flip-vertical":
          sliderContainer.classList.add("transition-flip-vertical-out");
          break;
        case "rotate":
          sliderContainer.classList.add("transition-rotate-out");
          break;
        case "blur":
          sliderContainer.classList.add("transition-blur-out");
          break;
        case "squeeze":
          sliderContainer.classList.add("transition-squeeze-out");
          break;
        default:
          sliderContainer.classList.add("transition-fade-out");
      }
      setTimeout(async () => {
        sliderContainer.empty();
        if (settings.captionMode === "below")
          captionContainer.empty();
        if (thumbnailEls.length > 0) {
          thumbnailEls.forEach((thumb, idx) => {
            thumb.classList.toggle("active-thumbnail", idx === currentIndex);
          });
        }
        const currentEntry = files[currentIndex];
        let [fileName, caption] = currentEntry.split("|").map((s) => s.trim());
        if (!fileName.includes(".")) {
          const mdFile = this.app.metadataCache.getFirstLinkpathDest(fileName, "");
          if (mdFile && mdFile.extension === "md") {
            fileName = mdFile.path;
          }
        }
        const filePath = this.getMediaSource(fileName);
        const mediaWrapper = sliderContainer.createDiv("media-wrapper");
        if (/\.(png|jpg|jpeg|gif)$/i.test(fileName)) {
          try {
            const compressedUrl = await compressImage(filePath, 800, 600, 0.7);
            const img = mediaWrapper.createEl("img", { attr: { src: compressedUrl } });
            img.classList.add("slider-media");
          } catch (err) {
            const img = mediaWrapper.createEl("img", { attr: { src: filePath } });
            img.classList.add("slider-media");
          }
        } else if (/\.(mp4|webm)$/i.test(fileName)) {
          const video = mediaWrapper.createEl("video", { attr: { src: filePath, controls: "true" } });
          if (settings.autoplay)
            video.setAttribute("autoplay", "true");
          video.classList.add("slider-media");
          if (this.settings.enableVisualizer) {
            new Visualizer(video, sliderContainer, {
              color: this.settings.visualizerColor,
              height: this.settings.visualizerHeight
            });
          }
        } else if (/\.(mp3|ogg|wav)$/i.test(fileName)) {
          const audio = mediaWrapper.createEl("audio", { attr: { src: filePath, controls: "true" } });
          audio.classList.add("slider-media", "audio-media");
          if (this.settings.enableVisualizer) {
            new Visualizer(audio, sliderContainer, {
              color: this.settings.visualizerColor,
              height: this.settings.visualizerHeight
            });
          }
        } else if (/\.(pdf)$/i.test(fileName)) {
          const iframe = mediaWrapper.createEl("iframe", { attr: { src: filePath, width: "100%", height: "100%" } });
          iframe.classList.add("slider-media");
        } else if (/\.(md)$/i.test(fileName)) {
          const abstractFile = this.app.vault.getAbstractFileByPath(fileName);
          if (abstractFile && "extension" in abstractFile) {
            const content = await this.getMarkdownContent(fileName);
            mediaWrapper.empty();
            await import_obsidian.MarkdownRenderer.render(this.app, content, mediaWrapper, abstractFile.path, this);
          }
        } else {
          const link = mediaWrapper.createEl("a", { text: "Open File", attr: { href: filePath, target: "_blank" } });
          link.classList.add("slider-media");
        }
        if (caption) {
          if (settings.captionMode === "overlay") {
            const capEl = mediaWrapper.createEl("div", { text: caption });
            capEl.classList.add("slider-caption-overlay");
          } else {
            const capEl = captionContainer.createEl("div", { text: caption });
            capEl.classList.add("slider-caption");
          }
        }
        if (settings.interactiveNotes && notesTextarea) {
          const mediaKey = `${sliderId}-${files[currentIndex]}`;
          notesTextarea.value = this.notesManager.getNote(mediaKey);
        }
        if (this.settings.enableDrawingAnnotation) {
          const mediaKey = `${sliderId}-${files[currentIndex]}`;
          updateDrawingOverlay == null ? void 0 : updateDrawingOverlay(mediaKey);
        }
        void mediaWrapper.offsetWidth;
        sliderContainer.classList.remove(
          "transition-fade-out",
          "transition-slide-next-out",
          "transition-slide-prev-out",
          "transition-zoom-out",
          "transition-slide-up-out",
          "transition-slide-down-out",
          "transition-flip-out",
          "transition-flip-vertical-out",
          "transition-rotate-out",
          "transition-blur-out",
          "transition-squeeze-out"
        );
        switch (settings.transitionEffect) {
          case "fade":
            sliderContainer.classList.add("transition-fade-in");
            break;
          case "slide":
            sliderContainer.classList.add(currentDirection === "next" ? "transition-slide-next-in" : "transition-slide-prev-in");
            break;
          case "zoom":
            sliderContainer.classList.add("transition-zoom-in");
            break;
          case "slide-up":
            sliderContainer.classList.add("transition-slide-up-in");
            break;
          case "slide-down":
            sliderContainer.classList.add("transition-slide-down-in");
            break;
          case "flip":
            sliderContainer.classList.add("transition-flip-in");
            break;
          case "flip-vertical":
            sliderContainer.classList.add("transition-flip-vertical-in");
            break;
          case "rotate":
            sliderContainer.classList.add("transition-rotate-in");
            break;
          case "blur":
            sliderContainer.classList.add("transition-blur-in");
            break;
          case "squeeze":
            sliderContainer.classList.add("transition-squeeze-in");
            break;
          default:
            sliderContainer.classList.add("transition-fade-in");
        }
      }, settings.transitionDuration);
    };
    const throttledUpdate = this.throttle(updateMediaDisplay, 100);
    const goPrev = () => {
      currentDirection = "prev";
      currentIndex = (currentIndex - 1 + files.length) % files.length;
      throttledUpdate();
    };
    const goNext = () => {
      currentDirection = "next";
      currentIndex = (currentIndex + 1) % files.length;
      throttledUpdate();
    };
    prevBtn.onclick = goPrev;
    nextBtn.onclick = goNext;
    sliderContent.addEventListener("mouseenter", () => sliderContent.focus());
    sliderContent.addEventListener("mouseleave", () => sliderContent.blur());
    sliderContent.tabIndex = 0;
    sliderContent.addEventListener("keydown", (evt) => {
      if (evt.key === "ArrowLeft")
        goPrev();
      else if (evt.key === "ArrowRight")
        goNext();
    });
    sliderContent.addEventListener("wheel", (evt) => {
      if (Math.abs(evt.deltaX) > Math.abs(evt.deltaY)) {
        if (evt.deltaX > 30) {
          goNext();
          evt.preventDefault();
        } else if (evt.deltaX < -30) {
          goPrev();
          evt.preventDefault();
        }
      }
    });
    let touchStartX = 0;
    sliderContent.addEventListener("touchstart", (evt) => {
      touchStartX = evt.touches[0].clientX;
    });
    sliderContent.addEventListener("touchend", (evt) => {
      const touchEndX = evt.changedTouches[0].clientX;
      const diff = touchStartX - touchEndX;
      if (Math.abs(diff) > 50)
        diff > 0 ? goNext() : goPrev();
    });
    throttledUpdate();
    if (thumbnailContainer) {
      thumbnailContainer.empty();
      files.forEach((entry, index) => {
        var _a;
        let [fileName] = entry.split("|").map((s) => s.trim());
        let thumbEl;
        if (/\.(png|jpg|jpeg|gif)$/i.test(fileName)) {
          thumbEl = thumbnailContainer.createEl("img", {
            attr: { src: this.getMediaSource(fileName) },
            cls: "thumbnail"
          });
        } else {
          const ext = ((_a = fileName.split(".").pop()) == null ? void 0 : _a.toUpperCase()) || "FILE";
          thumbEl = thumbnailContainer.createEl("div", { text: ext });
          thumbEl.classList.add("thumbnail-placeholder");
        }
        if (settings.thumbnailPosition === "left" || settings.thumbnailPosition === "right") {
          thumbEl.classList.add("vertical-thumb");
        }
        thumbEl.onclick = () => {
          currentIndex = index;
          throttledUpdate();
        };
        thumbnailEls.push(thumbEl);
      });
    }
    if (settings.slideshowSpeed > 0) {
      setInterval(goNext, settings.slideshowSpeed * 1e3);
    }
  }
};
var MediaSliderPlugin = _MediaSliderPlugin;
MediaSliderPlugin.sliderCounter = 0;
var MediaSliderSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Enable drawing annotation").setDesc("Toggle to enable drawing annotations on the slider. (default: off)").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableDrawingAnnotation).onChange(async (value) => {
        this.plugin.settings.enableDrawingAnnotation = value;
        await this.plugin.saveSettings();
        this.plugin.refreshSliders();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Enable visualizer").setDesc("Toggle to enable wave-like visualization for audio/video playback.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableVisualizer).onChange(async (value) => {
        this.plugin.settings.enableVisualizer = value;
        await this.plugin.saveSettings();
        this.plugin.refreshSliders();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Visualizer color").setDesc("CSS color value for the visualizer wave.").addText(
      (text) => text.setValue(this.plugin.settings.visualizerColor).onChange(async (value) => {
        this.plugin.settings.visualizerColor = value;
        await this.plugin.saveSettings();
        this.plugin.refreshSliders();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Visualizer height").setDesc("Height of the visualizer (e.g., '50px').").addText(
      (text) => text.setValue(this.plugin.settings.visualizerHeight).onChange(async (value) => {
        this.plugin.settings.visualizerHeight = value;
        await this.plugin.saveSettings();
        this.plugin.refreshSliders();
      })
    );
  }
};


/* nosourcemap */